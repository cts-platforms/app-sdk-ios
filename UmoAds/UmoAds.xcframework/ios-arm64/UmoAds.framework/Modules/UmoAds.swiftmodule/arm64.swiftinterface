// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name UmoAds
import AVFAudio
import AVFoundation
import AVKit
import AdSupport
import AppTrackingTransparency
import AssetsLibrary
import Combine
import CommonCrypto
import Compression
import CoreFoundation
import CoreLocation
import CoreTelephony
import CubicAuth
import Dispatch
import EventKit
import Foundation
import MobileCoreServices
import Photos
import SDWebImage
import SSZipArchive
import Swift
import SystemConfiguration
import UIKit
@_exported import UmoAds
import WebKit
import os.log
import os
public func <- <T>(left: inout T, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func >>> <T>(left: T, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func <- <T>(left: inout T?, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func >>> <T>(left: T?, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func <- <T>(left: inout [T], right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func >>> <T>(left: [T], right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func <- <T>(left: inout [T]?, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func >>> <T>(left: [T]?, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func <- <T>(left: inout [Swift.String : T], right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func >>> <T>(left: [Swift.String : T], right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func <- <T>(left: inout [Swift.String : T]?, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
public func >>> <T>(left: [Swift.String : T]?, right: UmoAds.AKXMLMap) where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible
extension AKDataRequest {
  @discardableResult
  public func responseXMLObject<T>(queue: Dispatch.DispatchQueue = .main, keyPath: Swift.String? = nil, dataPreprocessor: UmoAds.DataPreprocessor = AKXMLMappableResponseSerializer<T>.defaultDataPreprocessor, mapToObject object: T? = nil, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = AKXMLMappableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = AKXMLMappableResponseSerializer<T>.defaultEmptyRequestMethods, options: UmoAds.AKXMLSerialization.AKReadingOptions = .default, completionHandler: @escaping (UmoAds.AFDataResponse<T>) -> Swift.Void) -> Self where T : UmoAds.AKXMLBaseMappable
  @discardableResult
  public func responseXMLArray<T>(queue: Dispatch.DispatchQueue = .main, keyPath: Swift.String? = nil, dataPreprocessor: UmoAds.DataPreprocessor = AKXMLMappableArrayResponseSerializer<T>.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = AKXMLMappableArrayResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = AKXMLMappableArrayResponseSerializer<T>.defaultEmptyRequestMethods, options: UmoAds.AKXMLSerialization.AKReadingOptions = .default, completionHandler: @escaping (UmoAds.AFDataResponse<[T]>) -> Swift.Void) -> Self where T : UmoAds.AKXMLBaseMappable
}
@_hasMissingDesignatedInitializers open class AKNetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: UmoAds.AKNetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping UmoAds.AKNetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension AKNetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus, b: UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
public protocol AKXMLTransformType {
  associatedtype Object
  associatedtype XML
  func transformFromXML(_ value: Any?) -> Self.Object?
  func transformToXML(_ value: Self.Object?) -> Self.XML?
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: UmoAds.AKSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: UmoAds.AKRequest, for session: UmoAds.AKSession, dueTo error: Swift.Error, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
}
public protocol AKRequestInterceptor : UmoAds.RequestAdapter, UmoAds.RequestRetrier {
}
extension AKRequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: UmoAds.AKSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: UmoAds.AKRequest, for session: UmoAds.AKSession, dueTo error: Swift.Error, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, UmoAds.AKSession, @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (UmoAds.AKRequest, UmoAds.AKSession, Swift.Error, @escaping (UmoAds.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : UmoAds.AKRequestInterceptor {
  public init(_ adaptHandler: @escaping UmoAds.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: UmoAds.AKSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
open class Retrier : UmoAds.AKRequestInterceptor {
  public init(_ retryHandler: @escaping UmoAds.RetryHandler)
  open func retry(_ request: UmoAds.AKRequest, for session: UmoAds.AKSession, dueTo error: Swift.Error, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
  @objc deinit
}
open class Interceptor : UmoAds.AKRequestInterceptor {
  final public let adapters: [UmoAds.RequestAdapter]
  final public let retriers: [UmoAds.RequestRetrier]
  public init(adaptHandler: @escaping UmoAds.AdaptHandler, retryHandler: @escaping UmoAds.RetryHandler)
  public init(adapter: UmoAds.RequestAdapter, retrier: UmoAds.RequestRetrier)
  public init(adapters: [UmoAds.RequestAdapter] = [], retriers: [UmoAds.RequestRetrier] = [], interceptors: [UmoAds.AKRequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: UmoAds.AKSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func retry(_ request: UmoAds.AKRequest, for session: UmoAds.AKSession, dueTo error: Swift.Error, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
  @objc deinit
}
open class AKXMLCDATATransform : UmoAds.AKXMLTransformType {
  public typealias Object = Swift.String
  public typealias XML = [Foundation.Data]
  public init(encoding: Swift.String.Encoding = .utf8, separator: Swift.String = "\n")
  public func transformFromXML(_ value: Any?) -> UmoAds.AKXMLCDATATransform.Object?
  public func transformToXML(_ value: Swift.String?) -> UmoAds.AKXMLCDATATransform.XML?
  @objc deinit
}
open class AKXMLEnumTransform<T> : UmoAds.AKXMLTransformType where T : Swift.RawRepresentable, T.RawValue : Swift.LosslessStringConvertible {
  public typealias Object = T
  public typealias XML = Swift.String
  public init()
  open func transformFromXML(_ value: Any?) -> UmoAds.AKXMLEnumTransform<T>.Object?
  open func transformToXML(_ value: T?) -> UmoAds.AKXMLEnumTransform<T>.XML?
  @objc deinit
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: UmoAds.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: UmoAds.AlamofireExtension<Self.ExtendedType> { get set }
}
extension AlamofireExtended {
  public static var af: UmoAds.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: UmoAds.AlamofireExtension<Self> {
    get
    set
  }
}
extension URLRequest {
  public var method: UmoAds.AKHTTPMethod? {
    get
    set
  }
  public func validate() throws
}
@objc @_hasMissingDesignatedInitializers public class AKHtmlAdView : UmoAds.AKWebView {
  @objc deinit
  public func webView(_ webView: UmoAds.AKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> UmoAds.AKWebView?
  public func webView(_ webView: UmoAds.AKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  public func webView(_ webView: UmoAds.AKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  @objc override dynamic public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
}
final public class AKURLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    public static func == (a: UmoAds.AKURLEncodedFormEncoder.ArrayEncoding, b: UmoAds.AKURLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: UmoAds.AKURLEncodedFormEncoder.BoolEncoding, b: UmoAds.AKURLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: UmoAds.AKURLEncodedFormEncoder.SpaceEncoding, b: UmoAds.AKURLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: UmoAds.AKURLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: UmoAds.AKURLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: UmoAds.AKURLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: UmoAds.AKURLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: UmoAds.AKURLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: UmoAds.AKURLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: UmoAds.AKURLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: UmoAds.AKURLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: UmoAds.AKURLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: UmoAds.AKURLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: UmoAds.AKURLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: UmoAds.AKURLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension String : UmoAds.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URL : UmoAds.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URLComponents : UmoAds.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension URLRequest : UmoAds.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequest {
  public init(url: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod, headers: UmoAds.AKHTTPHeaders? = nil) throws
}
extension AKArchive {
  final public func addEntry(with path: Swift.String, relativeTo baseURL: Foundation.URL, compressionMethod: UmoAds.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, fileURL: Foundation.URL, compressionMethod: UmoAds.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil) throws
  final public func addEntry(with path: Swift.String, type: UmoAds.AKEntry.EntryType, uncompressedSize: Swift.UInt32, modificationDate: Foundation.Date = Date(), permissions: Swift.UInt16? = nil, compressionMethod: UmoAds.CompressionMethod = .none, bufferSize: Swift.UInt32 = defaultWriteChunkSize, progress: Foundation.Progress? = nil, provider: (Swift.Int, Swift.Int) throws -> Foundation.Data) throws
  final public func remove(_ entry: UmoAds.AKEntry, bufferSize: Swift.UInt32 = defaultReadChunkSize, progress: Foundation.Progress? = nil) throws
}
public typealias AFResult<Success> = Swift.Result<Success, UmoAds.AKAFError>
@objc @_hasMissingDesignatedInitializers public class AKVPaidBridge : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public struct AKEntry : Swift.Equatable {
  public enum EntryType : Swift.Int {
    case file
    case directory
    case symlink
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func path(using encoding: Swift.String.Encoding) -> Swift.String
  public var path: Swift.String {
    get
  }
  public var fileAttributes: [Foundation.FileAttributeKey : Any] {
    get
  }
  public var checksum: UmoAds.CRC32 {
    get
  }
  public var type: UmoAds.AKEntry.EntryType {
    get
  }
  public var compressedSize: Swift.Int {
    get
  }
  public var uncompressedSize: Swift.Int {
    get
  }
  public static func == (lhs: UmoAds.AKEntry, rhs: UmoAds.AKEntry) -> Swift.Bool
}
open class AKSOAPInformation : UmoAds.AKXMLMappable {
  public var nodeName: Swift.String!
  public init(informationName: Swift.String, nameSpace: Swift.String)
  required public init?(map: UmoAds.AKXMLMap)
  open func mapping(map: UmoAds.AKXMLMap)
  @objc deinit
}
public typealias Parameters = [Swift.String : Any]
public protocol AKParameterEncoding {
  func encode(_ urlRequest: UmoAds.URLRequestConvertible, with parameters: UmoAds.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : UmoAds.AKParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: UmoAds.URLEncoding.Destination, b: UmoAds.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    public static func == (a: UmoAds.URLEncoding.ArrayEncoding, b: UmoAds.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: UmoAds.URLEncoding.BoolEncoding, b: UmoAds.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: UmoAds.URLEncoding {
    get
  }
  public static var queryString: UmoAds.URLEncoding {
    get
  }
  public static var httpBody: UmoAds.URLEncoding {
    get
  }
  public let destination: UmoAds.URLEncoding.Destination
  public let arrayEncoding: UmoAds.URLEncoding.ArrayEncoding
  public let boolEncoding: UmoAds.URLEncoding.BoolEncoding
  public init(destination: UmoAds.URLEncoding.Destination = .methodDependent, arrayEncoding: UmoAds.URLEncoding.ArrayEncoding = .brackets, boolEncoding: UmoAds.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: UmoAds.URLRequestConvertible, with parameters: UmoAds.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : UmoAds.AKParameterEncoding {
  public static var `default`: UmoAds.JSONEncoding {
    get
  }
  public static var prettyPrinted: UmoAds.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: UmoAds.URLRequestConvertible, with parameters: UmoAds.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: UmoAds.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
open class AKRetryPolicy : UmoAds.AKRequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<UmoAds.AKHTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<UmoAds.AKHTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = AKRetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = AKRetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = AKRetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<UmoAds.AKHTTPMethod> = AKRetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = AKRetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = AKRetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: UmoAds.AKRequest, for session: UmoAds.AKSession, dueTo error: Swift.Error, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
  open func shouldRetry(request: UmoAds.AKRequest, dueTo error: Swift.Error) -> Swift.Bool
  @objc deinit
}
open class ConnectionLostRetryPolicy : UmoAds.AKRetryPolicy {
  public init(retryLimit: Swift.UInt = AKRetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = AKRetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = AKRetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<UmoAds.AKHTTPMethod> = AKRetryPolicy.defaultRetryableHTTPMethods)
  override public init(retryLimit: Swift.UInt = super, exponentialBackoffBase: Swift.UInt = super, exponentialBackoffScale: Swift.Double = super, retryableHTTPMethods: Swift.Set<UmoAds.AKHTTPMethod> = super, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = super, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = super)
  @objc deinit
}
extension AKRequest {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Notification {
  public var request: UmoAds.AKRequest? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : UmoAds.AKEventMonitor {
  final public func requestDidResume(_ request: UmoAds.AKRequest)
  final public func requestDidSuspend(_ request: UmoAds.AKRequest)
  final public func requestDidCancel(_ request: UmoAds.AKRequest)
  final public func requestDidFinish(_ request: UmoAds.AKRequest)
  final public func request(_ request: UmoAds.AKRequest, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: UmoAds.AKRequest, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: UmoAds.AKRequest, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: UmoAds.AKRequest, didCompleteTask task: Foundation.URLSessionTask, with error: UmoAds.AKAFError?)
  @objc deinit
}
public enum UMOAdKitBannerState {
  case NONE
  case INITIALIZED
  case LOADING_IN_PROGRESS
  case DISPLAY_IN_PROGRESS
  case DISPLAYED
  case PREFETCHING_IN_PROGRESS
  case AUTO_PREFETCHING_IN_PROGRESS
  case PREFETCHED
  case MANUAL_REFRESH_IN_PROGRESS
  case AUTO_REFRESH_IN_PROGRESS
  case REMOVAL_IN_PROGRESS
  case CLICKED
  case PLACEHOLDER_DISPLAYED
  public static func == (a: UmoAds.UMOAdKitBannerState, b: UmoAds.UMOAdKitBannerState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Ads : UmoAds.UMOAdKitInitStatusListener {
  public func onInitStatus(initStatus: Swift.Bool, akError: UmoAds.UMOAdKitError)
}
extension Ads : UmoAds.UMOAdKitBannerAdListener {
  public func getUpdatedQSParams() -> UmoAds.UMOAdKitAdQueryParams?
  public func onBannerEvent(akSpotId: Swift.String?, bannerAdEvent: UmoAds.UMOAdKitBannerAdEvent, akError: UmoAds.UMOAdKitError)
}
@objc public enum AdSize : Swift.Int {
  case mobileBanner
  case largeMobileBanner
  case mediumRectangle
  case html
  case none
  public var size: CoreGraphics.CGSize {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Array : UmoAds.EmptyResponse where Element : UmoAds.AKXMLBaseMappable, Element : UmoAds.EmptyResponse {
  public static func emptyValue() -> Swift.Array<Element>
}
final public class AKXMLMappableArrayResponseSerializer<T> : UmoAds.ResponseSerializer where T : UmoAds.AKXMLBaseMappable {
  final public let dataPreprocessor: UmoAds.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod>
  final public let serializeCallback: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) throws -> [T]
  public init(dataPreprocessor: UmoAds.DataPreprocessor = AKXMLMappableArrayResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = AKXMLMappableArrayResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = AKXMLMappableArrayResponseSerializer.defaultEmptyRequestMethods, serializeCallback: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) throws -> [T])
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> [T]
  public typealias SerializedObject = [T]
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class GenericAdView : UmoAds.BaseAdView {
  @objc override public init(adSlotId: Swift.String, adSize: UmoAds.AdSize)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  override public func renderAd(adInsertionInfo: UmoAds.AdInsertionInfo, adViewToRemove: UmoAds.BaseAdView?) -> Swift.Bool
  override public func adWillExpire() -> Swift.Bool
  @objc deinit
}
public enum UMOAdKitAdPosition : Swift.Int, Swift.CaseIterable {
  case UNKNOWN
  case ABOVE_FOLD
  case BELOW_FOLD
  case HEADER
  case FOOTER
  case SIDEBAR
  case FULL_SCREEN
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UmoAds.UMOAdKitAdPosition]
  public typealias RawValue = Swift.Int
  public static var allCases: [UmoAds.UMOAdKitAdPosition] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public enum AKSOAPVersion : Swift.String {
  case version1point1
  case version1point2
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = UmoAds.DataResponse<Value, UmoAds.AKAFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: UmoAds.AKDataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : UmoAds.ResponseSerializer
  public init<Serializer>(_ request: UmoAds.AKDataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : UmoAds.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, UmoAds.AKAFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, UmoAds.AKAFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == UmoAds.DataResponsePublisher<Value>.Failure, S.Input == UmoAds.DataResponsePublisher<Value>.Output
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: UmoAds.AKDataRequest, queue: Dispatch.DispatchQueue)
}
extension AKDataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> UmoAds.DataResponsePublisher<T> where Serializer : UmoAds.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: UmoAds.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> UmoAds.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: UmoAds.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> UmoAds.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: UmoAds.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: UmoAds.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<UmoAds.AKHTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> UmoAds.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> UmoAds.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct AKDataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = UmoAds.DataStreamRequest.Stream<Value, UmoAds.AKAFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: UmoAds.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : UmoAds.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, UmoAds.AKAFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, UmoAds.AKAFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == UmoAds.AKDataStreamPublisher<Value>.Failure, S.Input == UmoAds.AKDataStreamPublisher<Value>.Output
}
extension DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> UmoAds.AKDataStreamPublisher<Serializer.SerializedObject> where Serializer : UmoAds.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> UmoAds.AKDataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> UmoAds.AKDataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: UmoAds.DataDecoder = JSONDecoder(), preprocessor: UmoAds.DataPreprocessor = PassthroughPreprocessor()) -> UmoAds.AKDataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct AKDownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = UmoAds.DownloadResponse<Value, UmoAds.AKAFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: UmoAds.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : UmoAds.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: UmoAds.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : UmoAds.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, UmoAds.AKAFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, UmoAds.AKAFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == UmoAds.AKDownloadResponsePublisher<Value>.Failure, S.Input == UmoAds.AKDownloadResponsePublisher<Value>.Output
}
extension DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> UmoAds.AKDownloadResponsePublisher<T> where Serializer : UmoAds.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> UmoAds.AKDownloadResponsePublisher<T> where Serializer : UmoAds.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> UmoAds.AKDownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: UmoAds.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> UmoAds.AKDownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: UmoAds.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> UmoAds.AKDownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: UmoAds.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: UmoAds.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<UmoAds.AKHTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> UmoAds.AKDownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension AKDownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: UmoAds.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> UmoAds.AKDownloadResponsePublisher<Foundation.URL?>
}
@objc @_inheritsConvenienceInitializers open class UMOAdKitBannerView : UIKit.UIView {
  open var bannerParams: UmoAds.UMOAdKitBannerParams?
  weak open var bannerAdListener: UmoAds.UMOAdKitBannerAdListener?
  @objc override dynamic open func awakeFromNib()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open var frame: CoreGraphics.CGRect {
    @objc get
    @objc set
  }
  @objc override dynamic open var bounds: CoreGraphics.CGRect {
    @objc get
    @objc set
  }
  @objc override dynamic open func didMoveToWindow()
  open func setBannerPlaceholder(bannerType: UmoAds.UMOAdKitBannerType) throws
  open func fetchBanner() throws
  open func showBanner(inSpotId: Swift.String? = nil) throws
  open func refreshBanner() throws
  open func removeBanner() throws
  open func setVisibility(isVisible: Swift.Bool) throws
  open func getBannerCreativeSize() throws -> UmoAds.UMOAdKitSize
  open func getBannerState() throws -> UmoAds.UMOAdKitBannerState
  public static func getBannerSizeByBannerType(bannerType: UmoAds.UMOAdKitBannerType) -> UmoAds.UMOAdKitSize
  @objc deinit
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class AKReachability {
  public typealias NetworkReachable = (UmoAds.AKReachability) -> ()
  public typealias NetworkUnreachable = (UmoAds.AKReachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: UmoAds.AKReachability.NetworkStatus, b: UmoAds.AKReachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: UmoAds.AKReachability.Connection
    public static func == (a: UmoAds.AKReachability.Connection, b: UmoAds.AKReachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: UmoAds.AKReachability.NetworkReachable?
  public var whenUnreachable: UmoAds.AKReachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: UmoAds.AKReachability.Connection {
    get
  }
  public var connection: UmoAds.AKReachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension AKReachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
final public class AKXMLMappableResponseSerializer<T> : UmoAds.ResponseSerializer where T : UmoAds.AKXMLBaseMappable {
  final public let dataPreprocessor: UmoAds.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod>
  final public let serializeCallback: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) throws -> T
  public init(dataPreprocessor: UmoAds.DataPreprocessor = AKXMLMappableResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = AKXMLMappableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = AKXMLMappableResponseSerializer.defaultEmptyRequestMethods, serializeCallback: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) throws -> T)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
@objc public enum LoggingLevel : Swift.Int {
  case none = 0
  case error
  case info
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension UIApplication {
  public class func getAKTopmostViewController() -> UIKit.UIViewController?
}
@objc public protocol AdViewListener {
  @objc func onAdLoadSuccess(adSlotId: Swift.String, adInsertionId: Swift.String, rendered: Swift.Bool, adView: UmoAds.BaseAdView)
  @objc func onAdLoadError(adSlotId: Swift.String, error: Swift.Error, adView: UmoAds.BaseAdView)
  @objc func onAdClickShouldOpenLink(adSlotId: Swift.String, url: Foundation.URL?, urlString: Swift.String, adView: UmoAds.BaseAdView) -> Swift.Bool
}
extension URLSessionConfiguration : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class AKWebView : WebKit.WKWebView, WebKit.WKUIDelegate, WebKit.WKNavigationDelegate, UIKit.UIGestureRecognizerDelegate, WebKit.WKScriptMessageHandler {
  @objc public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  @objc public func webViewDidClose(_ webView: WebKit.WKWebView)
  @objc public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  @objc public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationResponse: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  @objc public func webViewWebContentProcessDidTerminate(_ webView: WebKit.WKWebView)
  @objc public func webView(_ webView: WebKit.WKWebView, didCommit navigation: WebKit.WKNavigation)
  @objc public func webView(_ webView: WebKit.WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WebKit.WKNavigation)
  @objc public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation)
  @objc public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation)
  @objc public func webView(_ webView: WebKit.WKWebView, didFail navigation: WebKit.WKNavigation, withError error: Swift.Error)
  @objc public func webView(_ webView: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation, withError error: Swift.Error)
  @objc public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
  @objc override dynamic public init(frame: CoreGraphics.CGRect, configuration: WebKit.WKWebViewConfiguration)
  @objc deinit
}
public typealias AFDataResponse<Success> = UmoAds.DataResponse<Success, UmoAds.AKAFError>
public typealias AFDownloadResponse<Success> = UmoAds.DownloadResponse<Success, UmoAds.AKAFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> UmoAds.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> UmoAds.DataResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> UmoAds.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> UmoAds.DataResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> UmoAds.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> UmoAds.DownloadResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> UmoAds.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> UmoAds.DownloadResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public enum UMOAdKitBannerAdEvent : Swift.String {
  case NONE
  case BANNER_LOAD_STARTED
  case BANNER_DISPLAYED
  case BANNER_FETCHED
  case BANNER_AUTO_FETCHED
  case BANNER_EXPIRED
  case BANNER_CLICKED
  case BANNER_PLACEHOLDER_CLICKED
  case BANNER_EXPANDED
  case BANNER_COLLAPSED
  case BANNER_BACKGROUNDED
  case BANNER_FOREGROUNDED
  case BANNER_REFRESHED
  case BANNER_AUTO_REFRESHED
  case BANNER_REMOVED
  case BANNER_DISMISSED
  case BANNER_ERROR
  case BANNER_REPLAYING
  case BANNER_COMPLETED
  case BANNER_STOPPED
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class AKXMLSerialization {
  open class func isValidXMLObject(_ obj: Any) -> Swift.Bool
  open class func xmlObject(withString xmlString: Swift.String, using encoding: Swift.String.Encoding = .utf8, options: UmoAds.AKXMLSerialization.AKReadingOptions = .default) throws -> Any
  open class func xmlObject(with data: Foundation.Data, encoding: Swift.String.Encoding = .utf8, options: UmoAds.AKXMLSerialization.AKReadingOptions = .default) throws -> Any
  open class func data(withXMLObject obj: Any, addXMLDeclaration: Swift.Bool = false) throws -> Foundation.Data
  @objc deinit
}
extension AKArchive {
  final public func totalUnitCountForRemoving(_ entry: UmoAds.AKEntry) -> Swift.Int64
  final public func totalUnitCountForReading(_ entry: UmoAds.AKEntry) -> Swift.Int64
  final public func totalUnitCountForAddingItem(at url: Foundation.URL) -> Swift.Int64
}
public enum UMOAdKitInlineVideoPlayMode : Swift.String, Swift.CaseIterable {
  case NONE
  case AUTOPLAY_AUDIO_ON
  case AUTOPLAY_AUDIO_OFF
  case CLICKTOPLAY_AUDIO_ON
  case CLICKTOPLAY_AUDIO_OFF
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UmoAds.UMOAdKitInlineVideoPlayMode]
  public typealias RawValue = Swift.String
  public static var allCases: [UmoAds.UMOAdKitInlineVideoPlayMode] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class AKVPaidWebView : UmoAds.AKWebView {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class UMOAdKitRollAdParams : ObjectiveC.NSObject {
  public var adServerUrl: Swift.String?
  public var adTimeoutSeconds: Swift.Int
  public var videoTimeoutSeconds: Swift.Int
  public var pickHighBitrateCreative: Swift.Bool
  public var pickCreativeByNetwork: Swift.Bool
  public var adSlot: UmoAds.UMOAdKitAdSlot
  public var enableAdPrefetch: Swift.Bool
  public var autoPrefetchOnExpiry: Swift.Bool
  public var rollAdPlaylist: Swift.String?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
infix operator <- : DefaultPrecedence
infix operator >>> : DefaultPrecedence
public func <- <T>(left: inout T, right: UmoAds.AKXMLMap)
public func >>> <T>(left: T, right: UmoAds.AKXMLMap)
public func <- <T>(left: inout T?, right: UmoAds.AKXMLMap)
public func >>> <T>(left: T?, right: UmoAds.AKXMLMap)
public func <- <T>(left: inout T, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: T, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout T?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: T?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Array<T>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Array<T>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Array<T>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Array<T>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>?, right: UmoAds.AKXMLMap) where T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Set<T>, right: UmoAds.AKXMLMap) where T : Swift.Hashable, T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Set<T>, right: UmoAds.AKXMLMap) where T : Swift.Hashable, T : UmoAds.AKXMLBaseMappable
public func <- <T>(left: inout Swift.Set<T>?, right: UmoAds.AKXMLMap) where T : Swift.Hashable, T : UmoAds.AKXMLBaseMappable
public func >>> <T>(left: Swift.Set<T>?, right: UmoAds.AKXMLMap) where T : Swift.Hashable, T : UmoAds.AKXMLBaseMappable
public enum AKAnimationType {
  case systemActivityIndicator
  case horizontalCirclesPulse
  case lineScaling
  case singleCirclePulse
  case multipleCirclePulse
  case singleCircleScaleRipple
  case multipleCircleScaleRipple
  case circleSpinFade
  case lineSpinFade
  case circleRotateChase
  case circleStrokeSpin
  public static func == (a: UmoAds.AKAnimationType, b: UmoAds.AKAnimationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum AKAnimatedIcon {
  case succeed
  case failed
  case added
  public static func == (a: UmoAds.AKAnimatedIcon, b: UmoAds.AKAnimatedIcon) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AKProgressHUD {
  public class var animationType: UmoAds.AKAnimationType {
    get
    set
  }
  public class var colorBackground: UIKit.UIColor {
    get
    set
  }
  public class var colorHUD: UIKit.UIColor {
    get
    set
  }
  public class var colorAnimation: UIKit.UIColor {
    get
    set
  }
  public class var colorProgress: UIKit.UIColor {
    get
    set
  }
  public class var fontStatus: UIKit.UIFont {
    get
    set
  }
}
extension AKProgressHUD {
  public class func dismiss()
  public class func show(_ status: Swift.String? = nil, interaction: Swift.Bool = true)
  public class func show(_ status: Swift.String? = nil, icon animatedIcon: UmoAds.AKAnimatedIcon, interaction: Swift.Bool = true)
  public class func showSuccess(_ status: Swift.String? = nil, image: UIKit.UIImage? = nil, interaction: Swift.Bool = true)
  public class func showError(_ status: Swift.String? = nil, image: UIKit.UIImage? = nil, interaction: Swift.Bool = true)
  public class func showSucceed(_ status: Swift.String? = nil, interaction: Swift.Bool = true)
  public class func showFailed(_ status: Swift.String? = nil, interaction: Swift.Bool = true)
  public class func showAdded(_ status: Swift.String? = nil, interaction: Swift.Bool = true)
  public class func showProgress(_ progress: CoreGraphics.CGFloat, interaction: Swift.Bool = false)
  public class func showProgress(_ status: Swift.String?, _ progress: CoreGraphics.CGFloat, interaction: Swift.Bool = false)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AKProgressHUD : UIKit.UIView {
  @objc deinit
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : UmoAds.DataResponseSerializerProtocol, UmoAds.DownloadResponseSerializerProtocol {
  var dataPreprocessor: UmoAds.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : UmoAds.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : UmoAds.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension ResponseSerializer {
  public static var defaultDataPreprocessor: UmoAds.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: UmoAds.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension DownloadResponseSerializerProtocol where Self : UmoAds.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
extension AKDataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (UmoAds.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (UmoAds.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : UmoAds.DataResponseSerializerProtocol
}
extension DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (UmoAds.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (UmoAds.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : UmoAds.DownloadResponseSerializerProtocol
}
public struct URLResponseSerializer : UmoAds.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (UmoAds.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : UmoAds.ResponseSerializer {
  final public let dataPreprocessor: UmoAds.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod>
  public init(dataPreprocessor: UmoAds.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension AKDataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (UmoAds.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (UmoAds.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : UmoAds.ResponseSerializer {
  final public let dataPreprocessor: UmoAds.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod>
  public init(dataPreprocessor: UmoAds.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension AKDataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (UmoAds.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (UmoAds.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
final public class JSONResponseSerializer : UmoAds.ResponseSerializer {
  final public let dataPreprocessor: UmoAds.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: UmoAds.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension AKDataRequest {
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (UmoAds.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (UmoAds.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: UmoAds.Empty
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension Empty : UmoAds.EmptyResponse {
  public static func emptyValue() -> UmoAds.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension JSONDecoder : UmoAds.DataDecoder {
}
extension PropertyListDecoder : UmoAds.DataDecoder {
}
final public class DecodableResponseSerializer<T> : UmoAds.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: UmoAds.DataPreprocessor
  final public let decoder: UmoAds.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod>
  public init(dataPreprocessor: UmoAds.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: UmoAds.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension AKDataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: UmoAds.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (UmoAds.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: UmoAds.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: UmoAds.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<UmoAds.AKHTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (UmoAds.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : UmoAds.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: UmoAds.DataDecoder
  public let dataPreprocessor: UmoAds.DataPreprocessor
  public init(decoder: UmoAds.DataDecoder = JSONDecoder(), dataPreprocessor: UmoAds.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : UmoAds.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : UmoAds.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping UmoAds.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping UmoAds.DataStreamRequest.Handler<Serializer.SerializedObject, UmoAds.AKAFError>) -> Self where Serializer : UmoAds.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping UmoAds.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: UmoAds.DataDecoder = JSONDecoder(), preprocessor: UmoAds.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping UmoAds.DataStreamRequest.Handler<T, UmoAds.AKAFError>) -> Self where T : Swift.Decodable
}
public struct UMOAdKitException : Swift.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
open class AKXMLTransformOf<ObjectType, XMLType> : UmoAds.AKXMLTransformType {
  public typealias Object = ObjectType
  public typealias XML = XMLType
  public init(fromXML: @escaping (XMLType?) -> ObjectType?, toXML: @escaping (ObjectType?) -> XMLType?)
  open func transformFromXML(_ value: Any?) -> ObjectType?
  open func transformToXML(_ value: ObjectType?) -> XMLType?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(GPSCoordinates) @objcMembers public class GPSCoordinates : ObjectiveC.NSObject, Swift.Codable {
  @objc public var lat: Swift.Double
  @objc public var lon: Swift.Double
  @objc public var ele: Swift.Double
  @objc public var acc: Swift.Double
  @objc override dynamic public init()
  public init(lat: Swift.Double? = 0.0, lon: Swift.Double? = 0.0, ele: Swift.Double? = 0.0, acc: Swift.Double? = 0.0)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol AKCachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: UmoAds.ResponseCacher
  public static let doNotCache: UmoAds.ResponseCacher
  public let behavior: UmoAds.ResponseCacher.Behavior
  public init(behavior: UmoAds.ResponseCacher.Behavior)
}
extension ResponseCacher : UmoAds.AKCachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
open class AKSession {
  public static let `default`: UmoAds.AKSession
  final public let session: Foundation.URLSession
  final public let delegate: UmoAds.AKSessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: UmoAds.AKRequestInterceptor?
  final public let serverTrustManager: UmoAds.AKServerTrustManager?
  final public let redirectHandler: UmoAds.AKRedirectHandler?
  final public let cachedResponseHandler: UmoAds.AKCachedResponseHandler?
  final public let eventMonitor: UmoAds.CompositeEventMonitor
  final public let defaultEventMonitors: [UmoAds.AKEventMonitor]
  public init(session: Foundation.URLSession, delegate: UmoAds.AKSessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, serverTrustManager: UmoAds.AKServerTrustManager? = nil, redirectHandler: UmoAds.AKRedirectHandler? = nil, cachedResponseHandler: UmoAds.AKCachedResponseHandler? = nil, eventMonitors: [UmoAds.AKEventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: UmoAds.AKSessionDelegate = AKSessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, serverTrustManager: UmoAds.AKServerTrustManager? = nil, redirectHandler: UmoAds.AKRedirectHandler? = nil, cachedResponseHandler: UmoAds.AKCachedResponseHandler? = nil, eventMonitors: [UmoAds.AKEventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<UmoAds.AKRequest>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .get, parameters: UmoAds.Parameters? = nil, encoding: UmoAds.AKParameterEncoding = URLEncoding.default, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.AKDataRequest
  open func request<Parameters>(_ convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .get, parameters: Parameters? = nil, encoder: UmoAds.AKParameterEncoder = URLEncodedFormParameterEncoder.default, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.AKDataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: UmoAds.URLRequestConvertible, interceptor: UmoAds.AKRequestInterceptor? = nil) -> UmoAds.AKDataRequest
  open func streamRequest<Parameters>(_ convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .get, parameters: Parameters? = nil, encoder: UmoAds.AKParameterEncoder = URLEncodedFormParameterEncoder.default, headers: UmoAds.AKHTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: UmoAds.AKRequestInterceptor? = nil, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .get, headers: UmoAds.AKHTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: UmoAds.AKRequestInterceptor? = nil, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.DataStreamRequest
  open func streamRequest(_ convertible: UmoAds.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: UmoAds.AKRequestInterceptor? = nil) -> UmoAds.DataStreamRequest
  open func download(_ convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .get, parameters: UmoAds.Parameters? = nil, encoding: UmoAds.AKParameterEncoding = URLEncoding.default, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, requestModifier: UmoAds.AKSession.RequestModifier? = nil, to destination: UmoAds.DownloadRequest.Destination? = nil) -> UmoAds.DownloadRequest
  open func download<Parameters>(_ convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .get, parameters: Parameters? = nil, encoder: UmoAds.AKParameterEncoder = URLEncodedFormParameterEncoder.default, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, requestModifier: UmoAds.AKSession.RequestModifier? = nil, to destination: UmoAds.DownloadRequest.Destination? = nil) -> UmoAds.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: UmoAds.URLRequestConvertible, interceptor: UmoAds.AKRequestInterceptor? = nil, to destination: UmoAds.DownloadRequest.Destination? = nil) -> UmoAds.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: UmoAds.AKRequestInterceptor? = nil, to destination: UmoAds.DownloadRequest.Destination? = nil) -> UmoAds.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .post, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: UmoAds.URLRequestConvertible, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> UmoAds.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .post, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: UmoAds.URLRequestConvertible, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> UmoAds.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: UmoAds.URLConvertible, method: UmoAds.AKHTTPMethod = .post, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: UmoAds.URLRequestConvertible, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> UmoAds.UploadRequest
  open func upload(multipartFormData: @escaping (UmoAds.AKMultipartFormData) -> Swift.Void, to url: UmoAds.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AKMultipartFormData.encodingMemoryThreshold, method: UmoAds.AKHTTPMethod = .post, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.UploadRequest
  open func upload(multipartFormData: @escaping (UmoAds.AKMultipartFormData) -> Swift.Void, with request: UmoAds.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AKMultipartFormData.encodingMemoryThreshold, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> UmoAds.UploadRequest
  open func upload(multipartFormData: UmoAds.AKMultipartFormData, to url: UmoAds.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AKMultipartFormData.encodingMemoryThreshold, method: UmoAds.AKHTTPMethod = .post, headers: UmoAds.AKHTTPHeaders? = nil, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: UmoAds.AKSession.RequestModifier? = nil) -> UmoAds.UploadRequest
  open func upload(multipartFormData: UmoAds.AKMultipartFormData, with request: UmoAds.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AKMultipartFormData.encodingMemoryThreshold, interceptor: UmoAds.AKRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> UmoAds.UploadRequest
}
extension AKSession : UmoAds.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: UmoAds.AKRequest)
  public func retryResult(for request: UmoAds.AKRequest, dueTo error: UmoAds.AKAFError, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: UmoAds.AKRequest, withDelay timeDelay: Foundation.TimeInterval?)
}
extension AKXMLSerialization {
  public struct AKReadingOptions : Swift.OptionSet {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let collapseTextNodes: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let stripEmptyNodes: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let trimWhiteSpace: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let alwaysUseArrays: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let preserveComments: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let wrapRootNode: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let keepNodesOrder: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let prefixedAttributes: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let unprefixedAttributes: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let dictionaryAttributes: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let discardAttributes: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let rootOnlyNodeName: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let alwaysNodeName: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let neverNodeName: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let cdataAsString: UmoAds.AKXMLSerialization.AKReadingOptions
    public static let `default`: UmoAds.AKXMLSerialization.AKReadingOptions
    public typealias ArrayLiteralElement = UmoAds.AKXMLSerialization.AKReadingOptions
    public typealias Element = UmoAds.AKXMLSerialization.AKReadingOptions
    public typealias RawValue = Swift.Int
  }
}
public struct AKXMLEncoding : UmoAds.AKParameterEncoding {
  public static var `default`: UmoAds.AKXMLEncoding {
    get
  }
  public init(withAction soapAction: Swift.String? = nil, soapVersion: UmoAds.AKSOAPVersion? = nil)
  public static func soap(withAction soapAction: Swift.String?, soapVersion: UmoAds.AKSOAPVersion = .version1point1) -> UmoAds.AKXMLEncoding
  public func encode(_ urlRequest: UmoAds.URLRequestConvertible, with parameters: UmoAds.Parameters?) throws -> Foundation.URLRequest
}
public struct AKHTTPHeaders {
  public init()
  public init(_ headers: [UmoAds.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: UmoAds.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: UmoAds.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> UmoAds.AKHTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension AKHTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension AKHTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: UmoAds.HTTPHeader...)
  public typealias ArrayLiteralElement = UmoAds.HTTPHeader
}
extension AKHTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[UmoAds.HTTPHeader]>
}
extension AKHTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> UmoAds.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = UmoAds.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<UmoAds.AKHTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[UmoAds.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<UmoAds.AKHTTPHeaders>
}
extension AKHTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: UmoAds.HTTPHeader, b: UmoAds.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension HTTPHeader {
  public static func accept(_ value: Swift.String) -> UmoAds.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> UmoAds.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> UmoAds.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> UmoAds.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> UmoAds.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> UmoAds.HTTPHeader
  public static func authorization(_ value: Swift.String) -> UmoAds.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> UmoAds.HTTPHeader
  public static func contentType(_ value: Swift.String) -> UmoAds.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> UmoAds.HTTPHeader
}
extension AKHTTPHeaders {
  public static let `default`: UmoAds.AKHTTPHeaders
}
extension HTTPHeader {
  public static let defaultAcceptEncoding: UmoAds.HTTPHeader
  public static let defaultAcceptLanguage: UmoAds.HTTPHeader
  public static let defaultUserAgent: UmoAds.HTTPHeader
}
extension URLRequest {
  public var headers: UmoAds.AKHTTPHeaders {
    get
    set
  }
}
extension HTTPURLResponse {
  public var headers: UmoAds.AKHTTPHeaders {
    get
  }
}
extension URLSessionConfiguration {
  public var headers: UmoAds.AKHTTPHeaders {
    get
    set
  }
}
public enum UMOAdKitRollAdEvent : Swift.String {
  case NONE
  case AD_FETCHED
  case AD_AUTO_FETCHED
  case AD_READY_TO_PLAY
  case AD_ERROR
  case AD_PLAYING
  case AD_COMPLETED
  case AD_CLICKED
  case AD_STOPPED
  case AD_EXPIRED
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum UMOAdKitBannerType : Swift.Int, Swift.CaseIterable {
  case NONE
  case MEDRECT_300x250_1x1
  case LEADERBOARD_300x50_6x1
  case LEADERBOARD_320x50_6x1
  case LARGE_320x100
  case SQUARE_250x250
  case SMALLSQUARE_200x200
  case FULLSIZE_468x60
  case LEADERBOARD_728x90_8x1
  case BILLBOARD_970x250
  case SUPERLEADERBOARD_970x90
  case PORTRAIT_300x1050
  case SKYSCRAPER_160x600
  case TWENTYxSIXTY_120x60
  case SMART_SWxH
  case ADAPTIVE_GWxAH
  case CUSTOM_GWxGH
  case INTERSTITIAL_640x1136
  case INTERSTITIAL_750x1334
  case INTERSTITIAL_1080x1920
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UmoAds.UMOAdKitBannerType]
  public typealias RawValue = Swift.Int
  public static var allCases: [UmoAds.UMOAdKitBannerType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public func <- <T>(left: inout T, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func >>> <T>(left: T, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func <- <T>(left: inout T?, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func >>> <T>(left: T?, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func <- <T>(left: inout [T], right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func >>> <T>(left: [T], right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func <- <T>(left: inout [T]?, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func >>> <T>(left: [T]?, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func <- <T>(left: inout [Swift.String : T], right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func >>> <T>(left: [Swift.String : T], right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func <- <T>(left: inout [Swift.String : T]?, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
public func >>> <T>(left: [Swift.String : T]?, right: UmoAds.AKXMLMap) where T : Swift.LosslessStringConvertible
open class AKXMLHexColorTransform : UmoAds.AKXMLTransformType {
  public typealias Object = UIKit.UIColor
  public typealias XML = Swift.String
  public init(prefixToXML: Swift.Bool = false, alphaToXML: Swift.Bool = false)
  open func transformFromXML(_ value: Any?) -> UmoAds.AKXMLHexColorTransform.Object?
  open func transformToXML(_ value: UmoAds.AKXMLHexColorTransform.Object?) -> UmoAds.AKXMLHexColorTransform.XML?
  @objc deinit
}
@objc open class AKSessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc override dynamic public init()
  @objc deinit
}
extension AKSessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
}
extension AKSessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension AKSessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension AKSessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
@_inheritsConvenienceInitializers @objc(UMOAdKit) open class UMOAdKit : ObjectiveC.NSObject {
  public static func initialize(adKitParams: UmoAds.UMOAdKitParams, initStatusListener: UmoAds.UMOAdKitInitStatusListener?) throws -> UmoAds.UMOAdKit?
  public static func getVersion() -> Swift.String
  public func updateParams(adKitParams: UmoAds.UMOAdKitParams) throws
  public func setLogLevel(inLogLevel: UmoAds.UMOAdKitLogLevel)
  public func getLogLevel() -> UmoAds.UMOAdKitLogLevel
  public func deInitialize() throws
  public func fetchInlineBannerForSpot(bannerParams: UmoAds.UMOAdKitBannerParams, bannerAdListener: UmoAds.UMOAdKitBannerAdListener?) throws
  public func fetchInlineBannersForSpots(bannerParamsList: Swift.Array<UmoAds.UMOAdKitBannerParams>, bannerAdListener: UmoAds.UMOAdKitBannerAdListener?) throws
  public func fetchBanners(bannerViews: Swift.Array<UmoAds.UMOAdKitBannerView>) throws
  public func showBanners(bannerViews: Swift.Array<UmoAds.UMOAdKitBannerView>, spotIds: Swift.Array<Swift.String>? = nil) throws
  public func refreshBanners(bannerViews: Swift.Array<UmoAds.UMOAdKitBannerView>) throws
  public func removeBanners(bannerViews: Swift.Array<UmoAds.UMOAdKitBannerView>) throws
  public func getCurrentOrientationAdaptiveBannerSize(width: Swift.Int) throws -> UmoAds.UMOAdKitSize
  public func getSmartBannerSize() throws -> UmoAds.UMOAdKitSize
  public func fetchInterstitialBanner(bannerParams: UmoAds.UMOAdKitBannerParams, bannerAdListener: UmoAds.UMOAdKitBannerAdListener?) throws
  public func showInterstitialBanner(bannerParams: UmoAds.UMOAdKitBannerParams, bannerAdListener: UmoAds.UMOAdKitBannerAdListener?) throws
  public func fetchRollAd(spotId: Swift.String, inRollAdParams: UmoAds.UMOAdKitRollAdParams?, rollAdListener: UmoAds.UMOAdKitRollAdListener?) throws
  public func showRollAd(spotId: Swift.String, inRollAdParams: UmoAds.UMOAdKitRollAdParams?, rollAdListener: UmoAds.UMOAdKitRollAdListener?) throws
  public func stopRollAd() throws
  public func setAutoPrefetchRollAdOnExpiry(autoPrefetchOnExpiry: Swift.Bool) throws
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AKNoConnectionException {
  public var message: Swift.String?
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class BaseAdView : UIKit.UIView {
  public var adSlotId: Swift.String!
  public var adSize: UmoAds.AdSize
  @objc weak public var adViewListener: UmoAds.AdViewListener? {
    @objc get
    @objc set
  }
  public init(adSlotId: Swift.String, adSize: UmoAds.AdSize)
  @discardableResult
  @objc public func addAspectRatioConstraints() -> UIKit.NSLayoutConstraint
  public func renderAd(adInsertionInfo: UmoAds.AdInsertionInfo, adViewToRemove: UmoAds.BaseAdView?) -> Swift.Bool
  public func adWillExpire() -> Swift.Bool
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
open class AKXMLCustomDateFormatTransform : UmoAds.AKXMLDateFormatterTransform {
  public init(formatString: Swift.String, withLocaleIdentifier localeIdentifier: Swift.String = "en_US_POSIX")
  override public init(dateFormatter: Foundation.DateFormatter)
  @objc deinit
}
open class AKNSDecimalNumberTransform : UmoAds.AKXMLTransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias XML = Swift.String
  public init()
  open func transformFromXML(_ value: Any?) -> UmoAds.AKNSDecimalNumberTransform.Object?
  open func transformToXML(_ value: Foundation.NSDecimalNumber?) -> UmoAds.AKNSDecimalNumberTransform.XML?
  @objc deinit
}
public enum UMOAdKitError : Swift.String {
  case NONE
  case DEVICE_OS_VERSION_NOT_SUPPORTED
  case AD_KIT_NOT_INITIALIZED
  case AD_KIT_ALREADY_INITIALIZED
  case AD_KIT_INITIALIZATION_ALREADY_IN_PROGRESS
  case INVALID_CONFIG_BASE_PATH
  case EXTERNAL_CONFIG_FETCH_FAILED
  case INVALID_EXTERNAL_CONFIG_PARAMS
  case EXTERNAL_CONFIG_MISSING_BANNER_AND_ROLL_PARAMS
  case INVALID_EXTERNAL_CONFIG_BANNER_PLAYLIST
  case INVALID_EXTERNAL_CONFIG_BANNER_SERVER_URL
  case INVALID_EXTERNAL_CONFIG_ROLL_PLAYLIST
  case INVALID_EXTERNAL_CONFIG_ROLL_SERVER_URL
  case EXTERNAL_CONFIG_FETCH_TIMED_OUT
  case REMOTE_AD_TEMPLATES_FETCH_FAILED
  case REMOTE_AD_TEMPLATES_INVALID
  case REMOTE_AD_TEMPLATES_FETCH_TIMED_OUT
  case AD_RENDERING_TEMPLATES_NOT_READY
  case AD_KIT_ROLL_SLOT_PARAMS_NOT_SET
  case AD_KIT_ROLL_SLOT_PARAMS_ALREADY_SET
  case INVALID_SPOT_ID
  case INVALID_SPOTS_INFO
  case INVALID_URL
  case INVALID_PUBLISHER_ID
  case INVALID_AD_SLOT
  case INVALID_AD_DATA
  case AD_REQUEST_FAILED
  case AD_RESPONSE_PROCESSING_ERROR
  case AD_TEMPLATE_MISSING
  case AD_REQUEST_TIMED_OUT
  case AD_PLAY_FAILED
  case AD_PLAY_TIMED_OUT
  case NETWORK_ERROR
  case PREVIOUS_AD_REQUEST_IN_PROGRESS
  case PREVIOUS_AD_PREFETCH_REQUEST_IN_PROGRESS
  case INVALID_BANNER_OPERATION
  case ROLLAD_OPERATION_NOT_ALLOWED_NOW
  case BANNER_OPERATION_NOT_ALLOWED_NOW
  case BANNER_REFRESH_ON_ORIENTATION_NOT_ALLOWED
  case BANNER_FETCH_FAILED
  case BANNER_SHOW_FAILED
  case BANNER_REFRESH_FAILED
  case BANNER_REMOVAL_FAILED
  case BANNER_AUTO_REFRESH_FAILED
  case INVALID_BANNER_PARAMS
  case INVALID_INLINE_BANNER_TYPE
  case INVALID_INTERSTITIAL_BANNER_TYPE
  case INVALID_BANNER_WIDTH
  case INVALID_BANNER_HEIGHT
  case EMPTY_AD_CONTENT
  case UNSUPPORTED_BANNER_TYPE
  case NO_AD_AVAILABLE_FOR_SPOT
  case AD_PREFETCH_NOT_ENABLED_IN_HOSTED_CONFIG
  case AD_PREFETCH_NOT_ENABLED
  case PREFETCHED_AD_ALREADY_EXISTS
  case EMPTY_RICH_MEDIA_AD_CONTENT
  case MISSING_MRAID_JS_IN_MRAID
  case API_NOT_ALLOWED_FOR_MULTISPOT_USECASE
  case INTERSTITIAL_NOT_ALLOWED_FOR_MULTISPOT_USECASE
  case API_NOT_ALLOWED_FOR_SINGLE_BANNER_USECASE
  case API_NOT_ALLOWED_FOR_INTERSTITIAL_USECASE
  case API_NOT_ALLOWED_FOR_VIDEO_SPOT
  case PREVIOUS_AD_PLAY_IN_PROGRESS
  case NO_AD_PLAY_IN_PROGRESS
  case NO_AD_AVAILABLE_FOR_SLOT
  case INTERSTITIAL_VIDEO_NOT_SUPPORTED_IN_BANNER_SLOT
  case AD_TYPE_UNSUPPORTED
  case BAD_INPUTS
  case INVALID_AD_VIEW
  case INVALID_ROLL_PARAMS
  case INVALID_HANDLE
  case UNKNOWN
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
open class AKXMLDateFormatterTransform : UmoAds.AKXMLTransformType {
  public typealias Object = Foundation.Date
  public typealias XML = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromXML(_ value: Any?) -> Foundation.Date?
  open func transformToXML(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
final public class AKXMLMapper<N> where N : UmoAds.AKXMLBaseMappable {
  public init()
  final public func map(XMLObject: Any?, toObject object: N) -> N
  final public func map(XMLString: Swift.String, toObject object: N) -> N
  final public func map(XML: [Swift.String : Any], toObject object: N) -> N
  final public func map(XMLString: Swift.String) -> N?
  final public func map(XMLObject: Any?) -> N?
  final public func map(XML: [Swift.String : Any]) -> N?
  final public func mapArray(XMLString: Swift.String) -> [N]?
  final public func mapArray(XMLObject: Any?) -> [N]?
  final public func mapArray(XMLArray: [Any]) -> [N]
  final public func mapDictionary(XMLString: Swift.String) -> [Swift.String : N]?
  final public func mapDictionary(XMLObject: Any?) -> [Swift.String : N]?
  final public func mapDictionary(XML: [Swift.String : Any]) -> [Swift.String : N]?
  final public func mapDictionary(XMLObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionary(XML: [Swift.String : Any], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionaryOfArrays(XMLObject: Any?) -> [Swift.String : [N]]?
  final public func mapDictionaryOfArrays(XML: [Swift.String : [Any]]) -> [Swift.String : [N]]?
  final public func mapArrayOfArrays(XMLObject: Any?) -> [[N]]?
  public static func parseXMLStringIntoDictionary(XMLString: Swift.String) -> [Swift.String : Any]?
  public static func parseXMLString(XMLString: Swift.String) -> Any?
  @objc deinit
}
extension AKXMLMapper {
  final public func map(XMLfile: Swift.String) -> N?
  final public func mapArray(XMLfile: Swift.String) -> [N]?
}
extension AKXMLMapper {
  final public func toXML(_ object: N) -> [Swift.String : Any]
  final public func toXMLArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toXMLDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toXMLDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  final public func toXMLString(_ object: N) -> Swift.String?
  final public func toXMLString(_ array: [N]) -> Swift.String?
  public static func toXMLString(_ XMLObject: Any) -> Swift.String?
}
extension AKXMLMapper where N : Swift.Hashable {
  final public func mapSet(XMLString: Swift.String) -> Swift.Set<N>?
  final public func mapSet(XMLObject: Any?) -> Swift.Set<N>?
  final public func mapSet(XMLArray: [Any]) -> Swift.Set<N>
  final public func toXMLSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  final public func toXMLString(_ set: Swift.Set<N>) -> Swift.String?
}
public enum AKXMLMappingType {
  case fromXML
  case toXML
  public static func == (a: UmoAds.AKXMLMappingType, b: UmoAds.AKXMLMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class AKXMLMap {
  final public var XML: [Swift.String : Any] {
    get
  }
  final public let mappingType: UmoAds.AKXMLMappingType
  final public var isKeyPresent: Swift.Bool {
    get
  }
  final public var currentValue: Any? {
    get
  }
  final public var currentKey: Swift.String? {
    get
  }
  final public var nestedKeyDelimiter: Swift.String {
    get
  }
  final public let toObject: Swift.Bool
  public init(mappingType: UmoAds.AKXMLMappingType, XML: [Swift.String : Any], toObject: Swift.Bool = false)
  final public subscript(key: Swift.String) -> UmoAds.AKXMLMap {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> UmoAds.AKXMLMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> UmoAds.AKXMLMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> UmoAds.AKXMLMap {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> UmoAds.AKXMLMap {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> UmoAds.AKXMLMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> UmoAds.AKXMLMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> UmoAds.AKXMLMap {
    get
  }
  final public func value<T>() -> T?
  final public var attributes: UmoAds.AKXMLMap {
    get
  }
  final public var innerText: UmoAds.AKXMLMap {
    get
  }
  final public var innerCDATA: UmoAds.AKXMLMap {
    get
  }
  final public var nodesOrder: UmoAds.AKXMLMap {
    get
  }
  @objc deinit
}
open class AKServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : UmoAds.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : UmoAds.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> UmoAds.ServerTrustEvaluating?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : UmoAds.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : UmoAds.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: UmoAds.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: UmoAds.RevocationTrustEvaluator.Options
    public static let ocsp: UmoAds.RevocationTrustEvaluator.Options
    public static let preferCRL: UmoAds.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: UmoAds.RevocationTrustEvaluator.Options
    public static let any: UmoAds.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = UmoAds.RevocationTrustEvaluator.Options
    public typealias Element = UmoAds.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: UmoAds.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class PinnedCertificatesTrustEvaluator : UmoAds.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class PublicKeysTrustEvaluator : UmoAds.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class CompositeTrustEvaluator : UmoAds.ServerTrustEvaluating {
  public init(evaluators: [UmoAds.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = UmoAds.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : UmoAds.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Array where Element == UmoAds.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Bundle : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension SecTrust : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (Darwin.OSStatus, Security.SecTrustResultType) -> Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (Darwin.OSStatus, Security.SecTrustResultType) -> Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension SecPolicy : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: UmoAds.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Array : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension SecCertificate : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Int32 : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension AlamofireExtension where ExtendedType == Darwin.OSStatus {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension SecTrustResultType : UmoAds.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
public let defaultReadChunkSize: Swift.UInt32
public let defaultWriteChunkSize: Swift.UInt32
public let defaultFilePermissions: Swift.UInt16
public let defaultDirectoryPermissions: Swift.UInt16
final public class AKArchive : Swift.Sequence {
  public enum ArchiveError : Swift.Error {
    case unreadableArchive
    case unwritableArchive
    case invalidEntryPath
    case invalidCompressionMethod
    case invalidStartOfCentralDirectoryOffset
    case missingEndOfCentralDirectoryRecord
    case invalidNumberOfEntriesOnDisk
    case invalidNumberOfEntriesInCentralDirectory
    case cancelledOperation
    case invalidBufferSize
    public static func == (a: UmoAds.AKArchive.ArchiveError, b: UmoAds.AKArchive.ArchiveError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AccessMode : Swift.UInt {
    case create
    case read
    case update
    public init?(rawValue: Swift.UInt)
    public typealias RawValue = Swift.UInt
    public var rawValue: Swift.UInt {
      get
    }
  }
  final public let url: Foundation.URL
  final public let accessMode: UmoAds.AKArchive.AccessMode
  public init?(url: Foundation.URL, accessMode mode: UmoAds.AKArchive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  public init?(data: Foundation.Data = Data(), accessMode mode: UmoAds.AKArchive.AccessMode, preferredEncoding: Swift.String.Encoding? = nil)
  @objc deinit
  final public func makeIterator() -> Swift.AnyIterator<UmoAds.AKEntry>
  final public subscript(path: Swift.String) -> UmoAds.AKEntry? {
    get
  }
  public typealias Element = UmoAds.AKEntry
  public typealias Iterator = Swift.AnyIterator<UmoAds.AKEntry>
}
@_hasMissingDesignatedInitializers public class AKSOAPBody : UmoAds.AKXMLMappable {
  public var nodeName: Swift.String!
  required public init?(map: UmoAds.AKXMLMap)
  public func mapping(map: UmoAds.AKXMLMap)
  @objc deinit
}
extension String {
  public func addTrailingSlash() -> Swift.String
}
@_hasMissingDesignatedInitializers public class AKSOAPHeader : UmoAds.AKXMLMappable {
  public var nodeName: Swift.String!
  required public init?(map: UmoAds.AKXMLMap)
  public func mapping(map: UmoAds.AKXMLMap)
  @objc deinit
}
public enum UMOAdKitAppUserType : Swift.String, Swift.CaseIterable {
  case LOGGED_IN_USER
  case ANONYMOUS_USER
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UmoAds.UMOAdKitAppUserType]
  public typealias RawValue = Swift.String
  public static var allCases: [UmoAds.UMOAdKitAppUserType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class UMOAdKitAdQueryParams : ObjectiveC.NSObject, Swift.Decodable {
  public var extraQSParams: Swift.String?
  public var appDomain: Swift.String?
  public var appStoreUrl: Swift.String?
  public var appCat: Swift.Array<Swift.String>?
  public var appSectioncat: Swift.Array<Swift.String>?
  public var appPagecat: Swift.Array<Swift.String>?
  public var appPrivacypolicy: Swift.Int?
  public var appPaid: Swift.Int?
  public var appKeywords: Swift.String?
  public var appPublisherName: Swift.String?
  public var appPpublisherCat: Swift.Array<Swift.String>?
  public var appContentId: Swift.String?
  public var appContentEpisode: Swift.Int?
  public var appContentTitle: Swift.String?
  public var appContentSeries: Swift.String?
  public var appContentSeason: Swift.String?
  public var appContentArtist: Swift.String?
  public var appContentGenre: Swift.String?
  public var appContentAlbum: Swift.String?
  public var appContentIsrc: Swift.String?
  public var appContentUrl: Swift.String?
  public var appContentCat: Swift.Array<Swift.String>?
  public var appContentProdq: Swift.Int?
  public var appContentContext: Swift.Int?
  public var appContentContentrating: Swift.String?
  public var appContentUserrating: Swift.String?
  public var appContentQagmediarating: Swift.Int?
  public var appContentKeywords: Swift.String?
  public var appContentLivestream: Swift.Int?
  public var appContentSourcerelationship: Swift.Int?
  public var appContentLen: Swift.Int?
  public var appContentLanguage: Swift.String?
  public var appContentEmbeddable: Swift.Int?
  public var appContentProducerId: Swift.String?
  public var appContentProducerName: Swift.String?
  public var appContentProducerCat: Swift.Array<Swift.String>?
  public var appContentProducerDomain: Swift.String?
  public var deviceGeoLat: Swift.String?
  public var deviceGeoLon: Swift.String?
  public var deviceGeoCountry: Swift.String?
  public var deviceGeoRegion: Swift.String?
  public var deviceGeoCity: Swift.String?
  public var deviceGeoZip: Swift.String?
  public var userYob: Swift.Int?
  public var userGender: Swift.String?
  public var userKeywords: Swift.String?
  public var userCustomdata: Swift.String?
  public var userGeoLat: Swift.String?
  public var userGeoLon: Swift.String?
  public var userGeoCountry: Swift.String?
  public var userGeoRegion: Swift.String?
  public var userGeoCity: Swift.String?
  public var userGeoZip: Swift.String?
  public var gdprCompliant: Swift.Int?
  @objc override dynamic public init()
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
public let AF: UmoAds.AKSession
extension UMOAdKitBannerView {
  @objc dynamic public func addAdaptiveAspectRatioConstraint()
}
extension AKRequest {
  public typealias ValidationResult = Swift.Result<Swift.Void, Swift.Error>
}
extension AKDataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> UmoAds.AKDataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension DataStreamRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse) -> UmoAds.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension DownloadRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?) -> UmoAds.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension String {
  public var xmlEncodedString: Swift.String {
    get
  }
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : UmoAds.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: UmoAds.AKSession, completion: @escaping (Swift.Result<Self.Credential, Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: UmoAds.AuthenticationError, b: UmoAds.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AKAuthenticationInterceptor<AuthenticatorType> : UmoAds.AKRequestInterceptor where AuthenticatorType : UmoAds.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: UmoAds.AKAuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: UmoAds.AKAuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: UmoAds.AKAuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: UmoAds.AKSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: UmoAds.AKRequest, for session: UmoAds.AKSession, dueTo error: Swift.Error, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
  @objc deinit
}
open class AKMultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: UmoAds.AKHTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
@objc public enum Environment : Swift.Int, Swift.CaseIterable {
  case prod
  case sandbox
  case dev
  case moovit
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [UmoAds.Environment]
  public typealias RawValue = Swift.Int
  public static var allCases: [UmoAds.Environment] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class UMOAdKitSize : ObjectiveC.NSObject {
  public var width: Swift.Int
  public var height: Swift.Int
  public init(w: Swift.Int, h: Swift.Int)
  @objc override dynamic public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class AKBrowserView : UIKit.UIView {
  public func didStartLoading()
  public func didFinishLoading(success: Swift.Bool)
  public func didDismissed()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public struct EmptyNetworkResponse : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol AKXMLBaseMappable {
  var nodeName: Swift.String! { get set }
  mutating func mapping(map: UmoAds.AKXMLMap)
}
public protocol AKXMLMappable : UmoAds.AKXMLBaseMappable {
  init?(map: UmoAds.AKXMLMap)
}
public protocol AKXMLStaticMappable : UmoAds.AKXMLBaseMappable {
  static func objectForMapping(map: UmoAds.AKXMLMap) -> UmoAds.AKXMLBaseMappable?
}
extension AKXMLBaseMappable {
  public init?(XMLString: Swift.String)
  public init?(XML: [Swift.String : Any])
  public func toXML() -> [Swift.String : Any]
  public func toXMLString() -> Swift.String?
}
extension Array where Element : UmoAds.AKXMLBaseMappable {
  public init?(XMLString: Swift.String)
  public init(XMLArray: [[Swift.String : Any]])
  public func toXML() -> [[Swift.String : Any]]
  public func toXMLString() -> Swift.String?
}
extension Set where Element : UmoAds.AKXMLBaseMappable {
  public init?(XMLString: Swift.String)
  public init?(XMLArray: [[Swift.String : Any]])
  public func toXML() -> [[Swift.String : Any]]
  public func toXMLString() -> Swift.String?
}
@objc public protocol AdListener {
  @objc func onAdLoadSuccess(adSlotId: Swift.String, adInsertionId: Swift.String, rendered: Swift.Bool, adView: UmoAds.BaseAdView)
  @objc func onAdLoadError(adSlotId: Swift.String, error: Swift.Error, adView: UmoAds.BaseAdView)
  @objc func onAdClickShouldOpenLink(adSlotId: Swift.String, url: Foundation.URL?, urlString: Swift.String, adView: UmoAds.BaseAdView) -> Swift.Bool
}
public func <- <AKTransform>(left: inout AKTransform.Object, right: (UmoAds.AKXMLMap, AKTransform)) where AKTransform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: Transform.Object, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout Transform.Object?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: Transform.Object?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout [Transform.Object], right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: [Transform.Object], right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout [Transform.Object]?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: [Transform.Object]?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object], right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object], right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object]?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout Transform.Object, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Transform.Object, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Transform.Object?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Transform.Object?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout [[Transform.Object]], right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: [[Transform.Object]], right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout [[Transform.Object]]?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func >>> <Transform>(left: [[Transform.Object]]?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType
public func <- <Transform>(left: inout Swift.Set<Transform.Object>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : Swift.Hashable, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Set<Transform.Object>, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : Swift.Hashable, Transform.Object : UmoAds.AKXMLBaseMappable
public func <- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : Swift.Hashable, Transform.Object : UmoAds.AKXMLBaseMappable
public func >>> <Transform>(left: Swift.Set<Transform.Object>?, right: (UmoAds.AKXMLMap, Transform)) where Transform : UmoAds.AKXMLTransformType, Transform.Object : Swift.Hashable, Transform.Object : UmoAds.AKXMLBaseMappable
extension AKArchive {
  final public var data: Foundation.Data? {
    get
  }
}
extension FileManager {
  public func zipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, shouldKeepParent: Swift.Bool = true, compressionMethod: UmoAds.CompressionMethod = .none, progress: Foundation.Progress? = nil) throws
  public func unzipItem(at sourceURL: Foundation.URL, to destinationURL: Foundation.URL, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, preferredEncoding: Swift.String.Encoding? = nil) throws
}
extension URL {
  public func isContained(in parentDirectoryURL: Foundation.URL) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class AKVPaidConstants : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
open class AKXMLURLTransform : UmoAds.AKXMLTransformType {
  public typealias Object = Foundation.URL
  public typealias XML = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = true, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  open func transformFromXML(_ value: Any?) -> UmoAds.AKXMLURLTransform.Object?
  open func transformToXML(_ value: Foundation.URL?) -> UmoAds.AKXMLURLTransform.XML?
  @objc deinit
}
open class AKXMLDateTransform : UmoAds.AKXMLTransformType {
  public typealias Object = Foundation.Date
  public typealias XML = Swift.Double
  public init()
  open func transformFromXML(_ value: Any?) -> Foundation.Date?
  open func transformToXML(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(AdPostInteractionResponseInfo) @objcMembers public class AdPostInteractionResponseInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol AKParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : UmoAds.AKParameterEncoder {
  public static var `default`: UmoAds.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: UmoAds.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: UmoAds.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
open class URLEncodedFormParameterEncoder : UmoAds.AKParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: UmoAds.URLEncodedFormParameterEncoder.Destination, b: UmoAds.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: UmoAds.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: UmoAds.AKURLEncodedFormEncoder
  final public let destination: UmoAds.URLEncodedFormParameterEncoder.Destination
  public init(encoder: UmoAds.AKURLEncodedFormEncoder = AKURLEncodedFormEncoder(), destination: UmoAds.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
open class AKXMLStringConvertibleTransform<T> : UmoAds.AKXMLTransformType where T : Swift.LosslessStringConvertible {
  public typealias Object = T
  public typealias XML = Swift.String
  public init()
  open func transformFromXML(_ value: Any?) -> UmoAds.AKXMLStringConvertibleTransform<T>.Object?
  open func transformToXML(_ value: T?) -> UmoAds.AKXMLStringConvertibleTransform<T>.XML?
  @objc deinit
}
public enum AdsError : Foundation.LocalizedError {
  case consumerNotFound
  case clientIdAndSecret
  case emptyInsertionResponse
  case noNamedSession
  case memoryReferenceLost
  case adKitError(UmoAds.UMOAdKitError)
  case refreshTokenMissing
}
extension AdsError {
  public var errorDescription: Swift.String? {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers public class UMOAdKitParams : ObjectiveC.NSObject {
  @objc public var publisherId: Swift.String
  @objc public var configFileBasePath: Swift.String
  @objc public var regionId: Swift.String?
  @objc public var umoAppRegionId: Swift.String?
  @objc public var userId: Swift.String?
  public var appUserType: UmoAds.UMOAdKitAppUserType
  @objc public var placeholderClickUrl: Swift.String?
  @objc public var dictStaticAppPlaceholders: [Swift.String : Swift.String]?
  @objc public var adQueryParams: UmoAds.UMOAdKitAdQueryParams?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
open class AKSOAPMessage : UmoAds.AKXMLMappable {
  public var nodeName: Swift.String!
  public init(soapAction: Swift.String, nameSpace: Swift.String)
  required public init?(map: UmoAds.AKXMLMap)
  open func mapping(map: UmoAds.AKXMLMap)
  @objc deinit
}
public struct AKXMLDictionaryTransform<Key, Value> : UmoAds.AKXMLTransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : UmoAds.AKXMLMappable, Key.RawValue == Swift.String {
  public init()
  public func transformFromXML(_ value: Any?) -> [Key : Value]?
  public func transformToXML(_ value: [Key : Value]?) -> Any?
  public typealias Object = Swift.Dictionary<Key, Value>
  public typealias XML = Any
}
public enum UMOAdKitInlineBannerCreativeType : Swift.String, Swift.CaseIterable {
  case NONE
  case IMAGE
  case VIDEO
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UmoAds.UMOAdKitInlineBannerCreativeType]
  public typealias RawValue = Swift.String
  public static var allCases: [UmoAds.UMOAdKitInlineBannerCreativeType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public protocol AKRedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: UmoAds.Redirector
  public static let doNotFollow: UmoAds.Redirector
  public let behavior: UmoAds.Redirector.Behavior
  public init(behavior: UmoAds.Redirector.Behavior)
}
extension Redirector : UmoAds.AKRedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public enum NetworkError : Foundation.LocalizedError {
  case invalidCode(response: Foundation.HTTPURLResponse, responseText: Swift.String)
  case osError(Swift.Error)
  case dataParseFailure(Foundation.Data?)
  case unknownError
}
extension NetworkError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum UMOAdKitLogLevel : Swift.Int {
  case NONE
  case ERROR
  case WARNING
  case INFO
  case DEBUG
  case VERBOSE
  case ALL
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
open class AKXMLDataTransform : UmoAds.AKXMLTransformType {
  public typealias Object = Foundation.Data
  public typealias XML = Swift.String
  public init()
  open func transformFromXML(_ value: Any?) -> Foundation.Data?
  open func transformToXML(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
public enum UMOAdKitAdSlot : Swift.String, Swift.CaseIterable {
  case NONE
  case PREROLL
  case MIDROLL
  case POSTROLL
  public init?(rawValue: Swift.String)
  public typealias AllCases = [UmoAds.UMOAdKitAdSlot]
  public typealias RawValue = Swift.String
  public static var allCases: [UmoAds.UMOAdKitAdSlot] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct AKHTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: UmoAds.AKHTTPMethod
  public static let delete: UmoAds.AKHTTPMethod
  public static let get: UmoAds.AKHTTPMethod
  public static let head: UmoAds.AKHTTPMethod
  public static let options: UmoAds.AKHTTPMethod
  public static let patch: UmoAds.AKHTTPMethod
  public static let post: UmoAds.AKHTTPMethod
  public static let put: UmoAds.AKHTTPMethod
  public static let trace: UmoAds.AKHTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public protocol UMOAdKitInitStatusListener : AnyObject {
  func onInitStatus(initStatus: Swift.Bool, akError: UmoAds.UMOAdKitError)
}
public protocol UMOAdKitBannerAdListener : AnyObject {
  func onBannerEvent(akSpotId: Swift.String?, bannerAdEvent: UmoAds.UMOAdKitBannerAdEvent, akError: UmoAds.UMOAdKitError)
  func getUpdatedQSParams() -> UmoAds.UMOAdKitAdQueryParams?
}
public protocol UMOAdKitRollAdListener : AnyObject {
  func onRollAdEvent(akSpotId: Swift.String?, rollAdEvent: UmoAds.UMOAdKitRollAdEvent, akError: UmoAds.UMOAdKitError)
  func getUpdatedQSParams() -> UmoAds.UMOAdKitAdQueryParams?
}
public class AKSOAPEnvelope : UmoAds.AKXMLMappable {
  public var nodeName: Swift.String!
  public init(soapMessage: UmoAds.AKSOAPMessage, soapInformation: UmoAds.AKSOAPInformation? = nil, soapVersion: UmoAds.AKSOAPVersion = .version1point1)
  required public init?(map: UmoAds.AKXMLMap)
  public func mapping(map: UmoAds.AKXMLMap)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class UMOAdKitBannerParams : ObjectiveC.NSObject {
  public var akSpotId: Swift.String
  public var bannerType: UmoAds.UMOAdKitBannerType
  public var adServerUrl: Swift.String?
  public var bannerTimeoutSeconds: Swift.Int
  public var enableAdPrefetch: Swift.Bool
  public var autoPrefetchOnExpiry: Swift.Bool
  public var bannerCreativeType: UmoAds.UMOAdKitInlineBannerCreativeType
  public var bannerPlaylist: Swift.String?
  public var bannerPosition: UmoAds.UMOAdKitAdPosition
  public var stretchImageAdCreative: Swift.Bool
  public var bannerWidthMax: Swift.Int?
  public var bannerHeightMax: Swift.Int?
  public var autoRefreshInterval: Swift.Int
  public var inlineVideoPlayMode: UmoAds.UMOAdKitInlineVideoPlayMode
  public var bannerWidth: Swift.Int
  public var bannerHeight: Swift.Int
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
public typealias EmptyCompletionResult = (Swift.Result<UmoAds.EmptyNetworkResponse, Swift.Error>)
public typealias EmptyCompletion = (UmoAds.EmptyCompletionResult) -> Swift.Void
public typealias JWTToken = Swift.String
public typealias JWTProviderCompletion = (Swift.Result<(accessToken: UmoAds.JWTToken, refreshToken: UmoAds.JWTToken?), Swift.Error>) -> Swift.Void
public typealias JWTProviderClosure = (@escaping UmoAds.JWTProviderCompletion) -> Swift.Void
public typealias JWTProviderClosureObjC = ((UmoAds.JWTToken?, Swift.Error?) -> Swift.Void) -> Swift.Void
public typealias AdInsertionId = Swift.String
public typealias LoadAdResult = (Swift.Result<UmoAds.AdInsertionId, Swift.Error>)
public typealias LoadAdCompletion = (UmoAds.LoadAdResult) -> Swift.Void
public typealias AuthenticatedCompletion = (Swift.Bool) -> Swift.Void
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class Ads : ObjectiveC.NSObject {
  @objc public static let shared: UmoAds.Ads
  public static let version: Swift.String
  public var jwtTokenProvider: UmoAds.JWTProviderClosure? {
    get
  }
  @objc public var jwtTokenProviderObjC: UmoAds.JWTProviderClosureObjC? {
    @objc get
  }
  @objc public var adListener: UmoAds.AdListener? {
    @objc get
  }
  @objc public var umoAdKit: UmoAds.UMOAdKit?
  @objc public var umoAdKitParams: UmoAds.UMOAdKitParams
  @objc public var currentEnvironment: UmoAds.Environment {
    @objc get
  }
  public var adKitBannerListener: UmoAds.UMOAdKitBannerAdListener?
  @objc deinit
}
extension Ads {
  @objc dynamic public func setClientId(_ clientId: Swift.String, clientSecret: Swift.String)
  public func setJWTTokenProvider(jwtTokenProvider: UmoAds.JWTProviderClosure?)
  @objc dynamic public func setJWTTokenProviderObjC(jwtTokenProvider: UmoAds.JWTProviderClosureObjC?)
  @objc dynamic public func logout()
  @objc dynamic public func isAuthenticated(completion: @escaping UmoAds.AuthenticatedCompletion)
  @objc dynamic public func setEnvironment(_ environment: UmoAds.Environment)
  @objc dynamic public func getAnonymousId() -> Swift.String?
}
extension Ads {
  @objc dynamic public func updateLastKnownLocation(_ location: CoreLocation.CLLocation)
}
extension Ads {
  public func fetchInitializationParameters(completion: UmoAds.EmptyCompletion?)
  @objc dynamic public func fetchInitializationParametersObjC(completion: ((Swift.Error?) -> Swift.Void)?)
  public func prefetchAd(spotId: Swift.String, hostedParamsOverride: UmoAds.UMOAdKitBannerParams?, bannerType: UmoAds.UMOAdKitBannerType, completion: @escaping UmoAds.EmptyCompletion)
  @objc dynamic public func prefetchAdObjC(spotId: Swift.String, hostedParamsOverride: UmoAds.UMOAdKitBannerParams?, bannerType: UmoAds.UMOAdKitBannerType, completion: @escaping ((Swift.Error?) -> Swift.Void))
  public func showAd(spotId: Swift.String, bannerView: UmoAds.UMOAdKitBannerView, assignHostedParams: Swift.Bool = true, bannerType: UmoAds.UMOAdKitBannerType, completion: @escaping UmoAds.EmptyCompletion)
  @objc dynamic public func showAdObjC(spotId: Swift.String, bannerView: UmoAds.UMOAdKitBannerView, assignHostedParams: Swift.Bool = true, bannerType: UmoAds.UMOAdKitBannerType, completion: @escaping ((Swift.Error?) -> Swift.Void))
  @objc dynamic public func generateHostedBannerParams(spotId: Swift.String, bannerType: UmoAds.UMOAdKitBannerType) -> UmoAds.UMOAdKitBannerParams
  @objc dynamic public func getOrGenerateBannerAd(spotId: Swift.String) -> UmoAds.UMOAdKitBannerView
  public func parentViewControllerDeinitializingFor(adView: UmoAds.UMOAdKitBannerView, completion: UmoAds.EmptyCompletion? = nil)
  @objc dynamic public func parentViewControllerDeinitializingForObjC(adView: UmoAds.UMOAdKitBannerView, completion: ((Swift.Error?) -> Swift.Void)? = nil)
  public func parentViewControllerAppearingFor(adView: UmoAds.UMOAdKitBannerView, completion: UmoAds.EmptyCompletion? = nil)
  @objc dynamic public func parentViewControllerAppearingForObjC(adView: UmoAds.UMOAdKitBannerView, completion: ((Swift.Error?) -> Swift.Void)? = nil)
  public func loadAd(adView: UmoAds.BaseAdView, completion: UmoAds.LoadAdCompletion? = nil)
  @objc dynamic public func loadAd(adView: UmoAds.BaseAdView, completion: ((UmoAds.AdInsertionId?, Swift.Error?) -> Swift.Void)?)
  @objc dynamic public func setPlaceholderImage(adSize: UmoAds.AdSize, placeholder: UIKit.UIImage)
  @objc dynamic public func placeholderImage(adSize: UmoAds.AdSize) -> UIKit.UIImage?
  @objc dynamic public func setGenericPlaceholder(assetTitle: Swift.String)
  @objc dynamic public func setGenericPlaceholderClickURL(_ clickURL: Swift.String)
  @objc dynamic public func setUniversalAdListener(_ adListener: UmoAds.AdListener)
  @objc dynamic public func updateUmoRegionId(_ regionId: Swift.UInt64, shouldRefreshAllAds: Swift.Bool = true)
  @objc dynamic public func updateRegionId(_ regionId: Swift.UInt64, shouldRefreshAllAds: Swift.Bool = true)
  @objc dynamic public func clearCache()
}
extension Ads {
  @objc dynamic public func setLoggerLevel(_ level: UmoAds.LoggingLevel)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(AdInsertionInfo) @objcMembers public class AdInsertionInfo : ObjectiveC.NSObject, Swift.Codable {
  required public init(from decoder: Swift.Decoder)
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
extension AKXMLSerialization {
  public enum AKXMLSerializationError : Swift.String, Swift.Error {
    case invalidXMLDocument
    case invalidFoundationObject
    case invalidData
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum CompressionMethod : Swift.UInt16 {
  case none
  case deflate
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public typealias CRC32 = Swift.UInt32
public typealias Consumer = (Foundation.Data) throws -> Swift.Void
public typealias Provider = (Swift.Int, Swift.Int) throws -> Foundation.Data
extension Data {
  public func crc32(checksum: UmoAds.CRC32) -> UmoAds.CRC32
  public static func compress(size: Swift.Int, bufferSize: Swift.Int, provider: (Swift.Int, Swift.Int) throws -> Foundation.Data, consumer: (Foundation.Data) throws -> Swift.Void) throws -> UmoAds.CRC32
  public static func decompress(size: Swift.Int, bufferSize: Swift.Int, skipCRC32: Swift.Bool, provider: (Swift.Int, Swift.Int) throws -> Foundation.Data, consumer: (Foundation.Data) throws -> Swift.Void) throws -> UmoAds.CRC32
}
@_inheritsConvenienceInitializers @objc(AdPostInteractionInfo) @objcMembers public class AdPostInteractionInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc override dynamic public init()
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol AKEventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: UmoAds.AKRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: UmoAds.AKRequest, didFailToCreateURLRequestWithError error: UmoAds.AKAFError)
  func request(_ request: UmoAds.AKRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: UmoAds.AKRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: UmoAds.AKAFError)
  func request(_ request: UmoAds.AKRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: UmoAds.AKRequest, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: UmoAds.AKRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: UmoAds.AKRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: UmoAds.AKAFError)
  func request(_ request: UmoAds.AKRequest, didCompleteTask task: Foundation.URLSessionTask, with error: UmoAds.AKAFError?)
  func requestIsRetrying(_ request: UmoAds.AKRequest)
  func requestDidFinish(_ request: UmoAds.AKRequest)
  func requestDidResume(_ request: UmoAds.AKRequest)
  func request(_ request: UmoAds.AKRequest, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: UmoAds.AKRequest)
  func request(_ request: UmoAds.AKRequest, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: UmoAds.AKRequest)
  func request(_ request: UmoAds.AKRequest, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: UmoAds.AKDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: UmoAds.AKRequest.ValidationResult)
  func request(_ request: UmoAds.AKDataRequest, didParseResponse response: UmoAds.DataResponse<Foundation.Data?, UmoAds.AKAFError>)
  func request<Value>(_ request: UmoAds.AKDataRequest, didParseResponse response: UmoAds.DataResponse<Value, UmoAds.AKAFError>)
  func request(_ request: UmoAds.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: UmoAds.AKRequest.ValidationResult)
  func request<Value>(_ request: UmoAds.DataStreamRequest, didParseStream result: Swift.Result<Value, UmoAds.AKAFError>)
  func request(_ request: UmoAds.UploadRequest, didCreateUploadable uploadable: UmoAds.UploadRequest.Uploadable)
  func request(_ request: UmoAds.UploadRequest, didFailToCreateUploadableWithError error: UmoAds.AKAFError)
  func request(_ request: UmoAds.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: UmoAds.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, UmoAds.AKAFError>)
  func request(_ request: UmoAds.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: UmoAds.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: UmoAds.AKRequest.ValidationResult)
  func request(_ request: UmoAds.DownloadRequest, didParseResponse response: UmoAds.DownloadResponse<Foundation.URL?, UmoAds.AKAFError>)
  func request<Value>(_ request: UmoAds.DownloadRequest, didParseResponse response: UmoAds.DownloadResponse<Value, UmoAds.AKAFError>)
}
extension AKEventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: UmoAds.AKRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: UmoAds.AKRequest, didFailToCreateURLRequestWithError error: UmoAds.AKAFError)
  public func request(_ request: UmoAds.AKRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: UmoAds.AKRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: UmoAds.AKAFError)
  public func request(_ request: UmoAds.AKRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: UmoAds.AKRequest, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: UmoAds.AKRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: UmoAds.AKRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: UmoAds.AKAFError)
  public func request(_ request: UmoAds.AKRequest, didCompleteTask task: Foundation.URLSessionTask, with error: UmoAds.AKAFError?)
  public func requestIsRetrying(_ request: UmoAds.AKRequest)
  public func requestDidFinish(_ request: UmoAds.AKRequest)
  public func requestDidResume(_ request: UmoAds.AKRequest)
  public func request(_ request: UmoAds.AKRequest, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: UmoAds.AKRequest)
  public func request(_ request: UmoAds.AKRequest, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: UmoAds.AKRequest)
  public func request(_ request: UmoAds.AKRequest, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: UmoAds.AKDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: UmoAds.AKRequest.ValidationResult)
  public func request(_ request: UmoAds.AKDataRequest, didParseResponse response: UmoAds.DataResponse<Foundation.Data?, UmoAds.AKAFError>)
  public func request<Value>(_ request: UmoAds.AKDataRequest, didParseResponse response: UmoAds.DataResponse<Value, UmoAds.AKAFError>)
  public func request(_ request: UmoAds.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: UmoAds.AKRequest.ValidationResult)
  public func request<Value>(_ request: UmoAds.DataStreamRequest, didParseStream result: Swift.Result<Value, UmoAds.AKAFError>)
  public func request(_ request: UmoAds.UploadRequest, didCreateUploadable uploadable: UmoAds.UploadRequest.Uploadable)
  public func request(_ request: UmoAds.UploadRequest, didFailToCreateUploadableWithError error: UmoAds.AKAFError)
  public func request(_ request: UmoAds.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: UmoAds.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, UmoAds.AKAFError>)
  public func request(_ request: UmoAds.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: UmoAds.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: UmoAds.AKRequest.ValidationResult)
  public func request(_ request: UmoAds.DownloadRequest, didParseResponse response: UmoAds.DownloadResponse<Foundation.URL?, UmoAds.AKAFError>)
  public func request<Value>(_ request: UmoAds.DownloadRequest, didParseResponse response: UmoAds.DownloadResponse<Value, UmoAds.AKAFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : UmoAds.AKEventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: UmoAds.AKRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: UmoAds.AKRequest, didFailToCreateURLRequestWithError error: UmoAds.AKAFError)
  final public func request(_ request: UmoAds.AKRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: UmoAds.AKRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: UmoAds.AKAFError)
  final public func request(_ request: UmoAds.AKRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: UmoAds.AKRequest, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: UmoAds.AKRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: UmoAds.AKRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: UmoAds.AKAFError)
  final public func request(_ request: UmoAds.AKRequest, didCompleteTask task: Foundation.URLSessionTask, with error: UmoAds.AKAFError?)
  final public func requestIsRetrying(_ request: UmoAds.AKRequest)
  final public func requestDidFinish(_ request: UmoAds.AKRequest)
  final public func requestDidResume(_ request: UmoAds.AKRequest)
  final public func request(_ request: UmoAds.AKRequest, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: UmoAds.AKRequest)
  final public func request(_ request: UmoAds.AKRequest, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: UmoAds.AKRequest)
  final public func request(_ request: UmoAds.AKRequest, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: UmoAds.AKDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: UmoAds.AKRequest.ValidationResult)
  final public func request(_ request: UmoAds.AKDataRequest, didParseResponse response: UmoAds.DataResponse<Foundation.Data?, UmoAds.AKAFError>)
  final public func request<Value>(_ request: UmoAds.AKDataRequest, didParseResponse response: UmoAds.DataResponse<Value, UmoAds.AKAFError>)
  final public func request(_ request: UmoAds.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: UmoAds.AKRequest.ValidationResult)
  final public func request<Value>(_ request: UmoAds.DataStreamRequest, didParseStream result: Swift.Result<Value, UmoAds.AKAFError>)
  final public func request(_ request: UmoAds.UploadRequest, didCreateUploadable uploadable: UmoAds.UploadRequest.Uploadable)
  final public func request(_ request: UmoAds.UploadRequest, didFailToCreateUploadableWithError error: UmoAds.AKAFError)
  final public func request(_ request: UmoAds.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: UmoAds.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, UmoAds.AKAFError>)
  final public func request(_ request: UmoAds.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: UmoAds.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: UmoAds.AKRequest.ValidationResult)
  final public func request(_ request: UmoAds.DownloadRequest, didParseResponse response: UmoAds.DownloadResponse<Foundation.URL?, UmoAds.AKAFError>)
  final public func request<Value>(_ request: UmoAds.DownloadRequest, didParseResponse response: UmoAds.DownloadResponse<Value, UmoAds.AKAFError>)
  @objc deinit
}
open class ClosureEventMonitor : UmoAds.AKEventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((UmoAds.AKRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((UmoAds.AKRequest, UmoAds.AKAFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((UmoAds.AKRequest, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((UmoAds.AKRequest, Foundation.URLRequest, UmoAds.AKAFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((UmoAds.AKRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((UmoAds.AKRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((UmoAds.AKRequest, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((UmoAds.AKRequest, Foundation.URLSessionTask, UmoAds.AKAFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((UmoAds.AKRequest, Foundation.URLSessionTask, UmoAds.AKAFError?) -> Swift.Void)?
  open var requestIsRetrying: ((UmoAds.AKRequest) -> Swift.Void)?
  open var requestDidFinish: ((UmoAds.AKRequest) -> Swift.Void)?
  open var requestDidResume: ((UmoAds.AKRequest) -> Swift.Void)?
  open var requestDidResumeTask: ((UmoAds.AKRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((UmoAds.AKRequest) -> Swift.Void)?
  open var requestDidSuspendTask: ((UmoAds.AKRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((UmoAds.AKRequest) -> Swift.Void)?
  open var requestDidCancelTask: ((UmoAds.AKRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((UmoAds.AKDataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, UmoAds.AKRequest.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((UmoAds.AKDataRequest, UmoAds.DataResponse<Foundation.Data?, UmoAds.AKAFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((UmoAds.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, UmoAds.AKRequest.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((UmoAds.UploadRequest, UmoAds.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((UmoAds.UploadRequest, UmoAds.AKAFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((UmoAds.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((UmoAds.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, UmoAds.AKAFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((UmoAds.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((UmoAds.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, UmoAds.AKRequest.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((UmoAds.DownloadRequest, UmoAds.DownloadResponse<Foundation.URL?, UmoAds.AKAFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: UmoAds.AKRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: UmoAds.AKRequest, didFailToCreateURLRequestWithError error: UmoAds.AKAFError)
  open func request(_ request: UmoAds.AKRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: UmoAds.AKRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: UmoAds.AKAFError)
  open func request(_ request: UmoAds.AKRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: UmoAds.AKRequest, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: UmoAds.AKRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: UmoAds.AKRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: UmoAds.AKAFError)
  open func request(_ request: UmoAds.AKRequest, didCompleteTask task: Foundation.URLSessionTask, with error: UmoAds.AKAFError?)
  open func requestIsRetrying(_ request: UmoAds.AKRequest)
  open func requestDidFinish(_ request: UmoAds.AKRequest)
  open func requestDidResume(_ request: UmoAds.AKRequest)
  public func request(_ request: UmoAds.AKRequest, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: UmoAds.AKRequest)
  public func request(_ request: UmoAds.AKRequest, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: UmoAds.AKRequest)
  public func request(_ request: UmoAds.AKRequest, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: UmoAds.AKDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: UmoAds.AKRequest.ValidationResult)
  open func request(_ request: UmoAds.AKDataRequest, didParseResponse response: UmoAds.DataResponse<Foundation.Data?, UmoAds.AKAFError>)
  public func request(_ request: UmoAds.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: UmoAds.AKRequest.ValidationResult)
  open func request(_ request: UmoAds.UploadRequest, didCreateUploadable uploadable: UmoAds.UploadRequest.Uploadable)
  open func request(_ request: UmoAds.UploadRequest, didFailToCreateUploadableWithError error: UmoAds.AKAFError)
  open func request(_ request: UmoAds.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: UmoAds.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, UmoAds.AKAFError>)
  open func request(_ request: UmoAds.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: UmoAds.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: UmoAds.AKRequest.ValidationResult)
  open func request(_ request: UmoAds.DownloadRequest, didParseResponse response: UmoAds.DownloadResponse<Foundation.URL?, UmoAds.AKAFError>)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AKVPaidProperties {
  @objc deinit
}
public enum AKAFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(UmoAds.AKAFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: UmoAds.AKAFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: UmoAds.AKAFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: UmoAds.AKAFError.ServerTrustFailureReason.Output, options: UmoAds.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: UmoAds.URLConvertible)
  case multipartEncodingFailed(reason: UmoAds.AKAFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: UmoAds.AKAFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: UmoAds.AKAFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: UmoAds.AKAFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: UmoAds.AKAFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: UmoAds.AKAFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: UmoAds.AKAFError.URLRequestValidationFailureReason)
}
extension Error {
  public var asAFError: UmoAds.AKAFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> UmoAds.AKAFError
}
extension AKAFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension AKAFError {
  public var urlConvertible: UmoAds.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
}
extension AKAFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension AKArchive {
  final public func extract(_ entry: UmoAds.AKEntry, to url: Foundation.URL, bufferSize: Swift.UInt32 = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil) throws -> UmoAds.CRC32
  final public func extract(_ entry: UmoAds.AKEntry, bufferSize: Swift.UInt32 = defaultReadChunkSize, skipCRC32: Swift.Bool = false, progress: Foundation.Progress? = nil, consumer: (Foundation.Data) throws -> Swift.Void) throws -> UmoAds.CRC32
}
@_hasMissingDesignatedInitializers public class AKRequest {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: UmoAds.AKRequest.State, b: UmoAds.AKRequest.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: UmoAds.AKEventMonitor?
  final public let interceptor: UmoAds.AKRequestInterceptor?
  weak public var delegate: UmoAds.RequestDelegate? {
    get
  }
  public var state: UmoAds.AKRequest.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: UmoAds.AKRedirectHandler? {
    get
  }
  public var cachedResponseHandler: UmoAds.AKCachedResponseHandler? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: UmoAds.AKAFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping UmoAds.AKRequest.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping UmoAds.AKRequest.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: UmoAds.AKRedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: UmoAds.AKCachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension AKRequest : Swift.Equatable {
  public static func == (lhs: UmoAds.AKRequest, rhs: UmoAds.AKRequest) -> Swift.Bool
}
extension AKRequest : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AKRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AKRequest {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: UmoAds.AKRequest)
  func retryResult(for request: UmoAds.AKRequest, dueTo error: UmoAds.AKAFError, completion: @escaping (UmoAds.RetryResult) -> Swift.Void)
  func retryRequest(_ request: UmoAds.AKRequest, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class AKDataRequest : UmoAds.AKRequest {
  final public let convertible: UmoAds.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping UmoAds.AKDataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : UmoAds.AKRequest {
  public typealias Handler<Success, Failure> = (UmoAds.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: UmoAds.DataStreamRequest.Event<Success, Failure>
    public let token: UmoAds.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(UmoAds.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: UmoAds.AKAFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: UmoAds.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping UmoAds.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: UmoAds.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : UmoAds.AKRequest {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: UmoAds.DownloadRequest.Options
    public static let removePreviousFile: UmoAds.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = UmoAds.DownloadRequest.Options
    public typealias Element = UmoAds.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (Foundation.URL, Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: UmoAds.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: UmoAds.DownloadRequest.Options = []) -> UmoAds.DownloadRequest.Destination
  public enum Downloadable {
    case request(UmoAds.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: UmoAds.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping UmoAds.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : UmoAds.AKDataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: UmoAds.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: UmoAds.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> UmoAds.UploadRequest.Uploadable
}
extension UploadRequest.Uploadable : UmoAds.UploadableConvertible {
  public func createUploadable() throws -> UmoAds.UploadRequest.Uploadable
}
public protocol UploadConvertible : UmoAds.URLRequestConvertible, UmoAds.UploadableConvertible {
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(AdResponseinfo) @objcMembers public class AdResponseInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension UmoAds.AKNetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension UmoAds.AKURLEncodedFormEncoder.ArrayEncoding : Swift.Equatable {}
extension UmoAds.AKURLEncodedFormEncoder.ArrayEncoding : Swift.Hashable {}
extension UmoAds.AKURLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension UmoAds.AKURLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension UmoAds.AKURLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension UmoAds.AKURLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension UmoAds.AKEntry.EntryType : Swift.Equatable {}
extension UmoAds.AKEntry.EntryType : Swift.Hashable {}
extension UmoAds.AKEntry.EntryType : Swift.RawRepresentable {}
extension UmoAds.URLEncoding.Destination : Swift.Equatable {}
extension UmoAds.URLEncoding.Destination : Swift.Hashable {}
extension UmoAds.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension UmoAds.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension UmoAds.URLEncoding.BoolEncoding : Swift.Equatable {}
extension UmoAds.URLEncoding.BoolEncoding : Swift.Hashable {}
extension UmoAds.UMOAdKitBannerState : Swift.Equatable {}
extension UmoAds.UMOAdKitBannerState : Swift.Hashable {}
extension UmoAds.AdSize : Swift.Equatable {}
extension UmoAds.AdSize : Swift.Hashable {}
extension UmoAds.AdSize : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitAdPosition : Swift.Equatable {}
extension UmoAds.UMOAdKitAdPosition : Swift.Hashable {}
extension UmoAds.UMOAdKitAdPosition : Swift.RawRepresentable {}
extension UmoAds.AKSOAPVersion : Swift.Equatable {}
extension UmoAds.AKSOAPVersion : Swift.Hashable {}
extension UmoAds.AKSOAPVersion : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension UmoAds.AKReachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension UmoAds.AKReachability.NetworkStatus : Swift.Hashable {}
extension UmoAds.AKReachability.Connection : Swift.Equatable {}
extension UmoAds.AKReachability.Connection : Swift.Hashable {}
extension UmoAds.LoggingLevel : Swift.Equatable {}
extension UmoAds.LoggingLevel : Swift.Hashable {}
extension UmoAds.LoggingLevel : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitBannerType : Swift.Equatable {}
extension UmoAds.UMOAdKitBannerType : Swift.Hashable {}
extension UmoAds.UMOAdKitBannerType : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitBannerAdEvent : Swift.Equatable {}
extension UmoAds.UMOAdKitBannerAdEvent : Swift.Hashable {}
extension UmoAds.UMOAdKitBannerAdEvent : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitInlineVideoPlayMode : Swift.Equatable {}
extension UmoAds.UMOAdKitInlineVideoPlayMode : Swift.Hashable {}
extension UmoAds.UMOAdKitInlineVideoPlayMode : Swift.RawRepresentable {}
extension UmoAds.AKAnimationType : Swift.Equatable {}
extension UmoAds.AKAnimationType : Swift.Hashable {}
extension UmoAds.AKAnimatedIcon : Swift.Equatable {}
extension UmoAds.AKAnimatedIcon : Swift.Hashable {}
extension UmoAds.UMOAdKitRollAdEvent : Swift.Equatable {}
extension UmoAds.UMOAdKitRollAdEvent : Swift.Hashable {}
extension UmoAds.UMOAdKitRollAdEvent : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitError : Swift.Equatable {}
extension UmoAds.UMOAdKitError : Swift.Hashable {}
extension UmoAds.UMOAdKitError : Swift.RawRepresentable {}
extension UmoAds.AKXMLMappingType : Swift.Equatable {}
extension UmoAds.AKXMLMappingType : Swift.Hashable {}
extension UmoAds.AKArchive.ArchiveError : Swift.Equatable {}
extension UmoAds.AKArchive.ArchiveError : Swift.Hashable {}
extension UmoAds.AKArchive.AccessMode : Swift.Equatable {}
extension UmoAds.AKArchive.AccessMode : Swift.Hashable {}
extension UmoAds.AKArchive.AccessMode : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitAppUserType : Swift.Equatable {}
extension UmoAds.UMOAdKitAppUserType : Swift.Hashable {}
extension UmoAds.UMOAdKitAppUserType : Swift.RawRepresentable {}
extension UmoAds.AuthenticationError : Swift.Equatable {}
extension UmoAds.AuthenticationError : Swift.Hashable {}
extension UmoAds.Environment : Swift.Equatable {}
extension UmoAds.Environment : Swift.Hashable {}
extension UmoAds.Environment : Swift.RawRepresentable {}
extension UmoAds.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension UmoAds.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
extension UmoAds.UMOAdKitInlineBannerCreativeType : Swift.Equatable {}
extension UmoAds.UMOAdKitInlineBannerCreativeType : Swift.Hashable {}
extension UmoAds.UMOAdKitInlineBannerCreativeType : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitLogLevel : Swift.Equatable {}
extension UmoAds.UMOAdKitLogLevel : Swift.Hashable {}
extension UmoAds.UMOAdKitLogLevel : Swift.RawRepresentable {}
extension UmoAds.UMOAdKitAdSlot : Swift.Equatable {}
extension UmoAds.UMOAdKitAdSlot : Swift.Hashable {}
extension UmoAds.UMOAdKitAdSlot : Swift.RawRepresentable {}
extension UmoAds.AKXMLSerialization.AKXMLSerializationError : Swift.Equatable {}
extension UmoAds.AKXMLSerialization.AKXMLSerializationError : Swift.Hashable {}
extension UmoAds.AKXMLSerialization.AKXMLSerializationError : Swift.RawRepresentable {}
extension UmoAds.CompressionMethod : Swift.Equatable {}
extension UmoAds.CompressionMethod : Swift.Hashable {}
extension UmoAds.CompressionMethod : Swift.RawRepresentable {}
extension UmoAds.AKRequest.State : Swift.Equatable {}
extension UmoAds.AKRequest.State : Swift.Hashable {}
